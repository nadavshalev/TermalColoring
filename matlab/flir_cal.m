
% Auto-generated by cameraCalibrator app on 27-Oct-2014
% Copyright 2014 - 2015 The MathWorks, Inc. 
%-------------------------------------------------------
% Define images to process
% imageFileNames = {'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000079.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000080.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000081.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000082.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000084.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000085.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000088.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000091.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000092.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000093.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000095.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000096.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000099.jpg',...
%     'C:\FLIR_Meeting\Demos\Camera Calibration\Snap-000100.jpg',...
%     };
folder = '../../../data/camTest/';
[name,path] = uigetfile([folder '*.png'], 'MultiSelect', 'on');
imageFileNames = [path, name];
% Detect checkerboards in images
[imagePoints, boardSize, imagesUsed] = detectCheckerboardPoints(imageFileNames);
imageFileNames = imageFileNames(imagesUsed);
% Generate world coordinates of the corners of the squares
squareSize = 22;  % in units of 'mm'
worldPoints = generateCheckerboardPoints(boardSize, squareSize);
% Calibrate the camera
[cameraParams, imagesUsed, estimationErrors] = estimateCameraParameters(imagePoints, worldPoints, ...
    'EstimateSkew', true, 'EstimateTangentialDistortion', true, ...
    'NumRadialDistortionCoefficients', 2, 'WorldUnits', 'mm');
% View reprojection errors
h1=figure; showReprojectionErrors(cameraParams, 'BarGraph');
% Visualize pattern locations
h2=figure; showExtrinsics(cameraParams, 'CameraCentric');
% Display parameter estimation errors
displayErrors(estimationErrors, cameraParams);
% For example, you can use the calibration data to remove effects of lens distortion.
originalImage = imread(imageFileNames{1});
undistortedImage = undistortImage(originalImage, cameraParams);
% See additional examples of how to use the calibration data.  At the prompt type:
% showdemo('MeasuringPlanarObjectsExample')
% showdemo('SparseReconstructionExample')
%%
%% Read in image to measure
imOrig = imread('cap2.png');
% imOrig = imread('Snap-000094.jpg');
figure; imshow(imOrig, 'InitialMagnification', squareSize);
title('Input Image');
%% Undistort the image
im = undistortImage(imOrig, cameraParameters);
d = abs(rgb2gray(im) - rgb2gray(imOrig));
figure; imshow(d, [], 'InitialMagnification', squareSize);
title('Difference Between the Original and the Undistorted Images');
 
%% Segment the Lens Cap
% Convert the image to the HSV color space.
% imgray = rgb2gray(imcomplement(im));
imgray = rgb2gray(im);
% Threshold the image
t = 0.83;
imCoin = im2bw(imgray, t);
% imCoin = imclearborder(imCoin);
% se = strel('disk', 0);
% imCoin = imopen(imCoin, se);
imshow(imCoin, 'InitialMagnification', squareSize);
title('Segmented Lens Cap');
%% Detect the Lens Cap
% Find connected components.
blobAnalysis = vision.BlobAnalysis('AreaOutputPort', true,...
    'CentroidOutputPort', false,...
    'BoundingBoxOutputPort', true,...
    'MinimumBlobArea', 200, 'ExcludeBorderBlobs', true);
[areas, boxes] = step(blobAnalysis, imCoin);
% Sort connected components in descending order by area
[~, idx] = sort(areas, 'Descend');
% Get the two largest components.
boxes = boxes(idx(1:1), :);
% Reduce the size of the image for display.
scale = squareSize / 100;
imDetectedLensCap = imresize(im, scale);
% Insert labels for the LensCap.
imDetectedLensCap = insertObjectAnnotation(imDetectedLensCap, 'rectangle', ...
    scale * boxes, 'LensCap');
figure; imshow(imDetectedLensCap);
title('Detected Lens Cap');
%%
[imagePoints, boardSize] = detectCheckerboardPoints(im);
% Compute rotation and translation of the camera.
[R, t] = extrinsics(imagePoints, worldPoints, cameraParams);
%% Measure first coin
% Get the top-left and the top-right corners.
box1 = double(boxes(1, :));
imagePoints1 = [box1(1:2); ...
                box1(1) + box1(3), box1(2)];
% Compute the transformation matrix from world to image
T = [R(1, :); R(2, :); t] * cameraParams.IntrinsicMatrix;
% Create a transformation object
tform = projective2d(T);
% Apply the inverse transformation from image to world
worldPoints1 = transformPointsInverse(tform, imagePoints1);
% Compute the diameter of the coin in millimeters.
d = worldPoints1(2, :) - worldPoints1(1, :);
diameterInMillimeters = hypot(d(1), d(2));
fprintf('Measured diameter of one Lens Cap = %0.2f mm\n', diameterInMillimeters);
